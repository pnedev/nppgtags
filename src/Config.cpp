/**
 *  \file
 *  \brief  GTags config class
 *
 *  \author  Pavel Nedev <pg.nedev@gmail.com>
 *
 *  \section COPYRIGHT
 *  Copyright(C) 2015-2019 Pavel Nedev
 *
 *  \section LICENSE
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License version 2 as published
 *  by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "INpp.h"
#include "Common.h"
#include "Config.h"
#include "GTags.h"


namespace GTags
{

const TCHAR Settings::cInfo[] =
        _T("# Configuration file for Notepad++ ") PLUGIN_NAME _T(" plugin\n")
        _T("# This file is automatically generated and will be overwritten")
        _T(" on next ") PLUGIN_NAME _T(" config\n");

const TCHAR Settings::cUseDefDbKey[]     = _T("UseDefaultDB = ");
const TCHAR Settings::cDefDbPathKey[]    = _T("DefaultDBPath = ");
const TCHAR Settings::cREOptionKey[]     = _T("RegExp = ");
const TCHAR Settings::cICOptionKey[]     = _T("IgnoreCase = ");

const TCHAR DbConfig::cInfo[] =
        _T("# ") PLUGIN_NAME _T(" database config\n");

const TCHAR DbConfig::cParserKey[]          = _T("Parser = ");
const TCHAR DbConfig::cAutoUpdateKey[]      = _T("AutoUpdate = ");
const TCHAR DbConfig::cUseLibDbKey[]        = _T("UseLibraryDBs = ");
const TCHAR DbConfig::cLibDbPathsKey[]      = _T("LibraryDBPaths = ");
const TCHAR DbConfig::cUsePathFilterKey[]   = _T("UsePathFilters = ");
const TCHAR DbConfig::cPathFiltersKey[]     = _T("PathFilters = ");
const TCHAR DbConfig::cUseSciAutoCKey[]     = _T("UseSciAutoC = ");
const TCHAR DbConfig::cSciAutoCIgnoreCaseKey[] = _T("SciAutoCIgnoreCase = ");
const TCHAR DbConfig::cSciAutoCFromNCharKey[]  = _T("SciAutoFromNChar = ");

const TCHAR DbConfig::cDefaultParser[]   = _T("default");
const TCHAR DbConfig::cCtagsParser[]     = _T("ctags");
const TCHAR DbConfig::cPygmentsParser[]  = _T("pygments");

const TCHAR* DbConfig::cParsers[DbConfig::PARSER_LIST_END] = {
    DbConfig::cDefaultParser,
    DbConfig::cCtagsParser,
    DbConfig::cPygmentsParser
};


/**
 *  \brief
 */
DbConfig::DbConfig()
{
    SetDefaults();
}


/**
 *  \brief
 */
void DbConfig::SetDefaults()
{
    _parserIdx = DEFAULT_PARSER;
    _autoUpdate = true;
    _useLibDb = false;
    _libDbPaths.clear();
    _usePathFilter = false;
    _pathFilters.clear();
    _useSciAutoC = false;
    _SciAutoCIgnoreCase = false;
    _SciAutoCFromNChar = 3;
}


/**
 *  \brief
 */
bool DbConfig::ReadOption(TCHAR* line)
{
    if (!_tcsncmp(line, cParserKey, _countof(cParserKey) - 1))
    {
        const unsigned pos = _countof(cParserKey) - 1;
        if (!_tcsncmp(&line[pos], cCtagsParser, _countof(cCtagsParser) - 1))
            _parserIdx = CTAGS_PARSER;
        else if (!_tcsncmp(&line[pos], cPygmentsParser, _countof(cPygmentsParser) - 1))
            _parserIdx = PYGMENTS_PARSER;
        else
            _parserIdx = DEFAULT_PARSER;
    }
    else if (!_tcsncmp(line, cAutoUpdateKey, _countof(cAutoUpdateKey) - 1))
    {
        const unsigned pos = _countof(cAutoUpdateKey) - 1;
        if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
            _autoUpdate = true;
        else
            _autoUpdate = false;
    }
    else if (!_tcsncmp(line, cUseLibDbKey, _countof(cUseLibDbKey) - 1))
    {
        const unsigned pos = _countof(cUseLibDbKey) - 1;
        if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
            _useLibDb = true;
        else
            _useLibDb = false;
    }
    else if (!_tcsncmp(line, cLibDbPathsKey, _countof(cLibDbPathsKey) - 1))
    {
        const unsigned pos = _countof(cLibDbPathsKey) - 1;
        DbPathsFromBuf(&line[pos], _T(";"));
    }
    else if (!_tcsncmp(line, cUsePathFilterKey, _countof(cUsePathFilterKey) - 1))
    {
        const unsigned pos = _countof(cUsePathFilterKey) - 1;
        if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
            _usePathFilter = true;
        else
            _usePathFilter = false;
    }
    else if (!_tcsncmp(line, cPathFiltersKey, _countof(cPathFiltersKey) - 1))
    {
        const unsigned pos = _countof(cPathFiltersKey) - 1;
        FiltersFromBuf(&line[pos], _T(";"));
    }
    else if (!_tcsncmp(line, cUseSciAutoCKey, _countof(cUseSciAutoCKey) - 1))
    {
        const unsigned pos = _countof(cUseSciAutoCKey) - 1;
        if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
            _useSciAutoC = true;
        else
            _useSciAutoC = false;
    }
    else if (!_tcsncmp(line, cSciAutoCIgnoreCaseKey, _countof(cSciAutoCIgnoreCaseKey) - 1))
    {
        const unsigned pos = _countof(cSciAutoCIgnoreCaseKey) - 1;
        if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
            _SciAutoCIgnoreCase = true;
        else
            _SciAutoCIgnoreCase = false;
    }
    else if (!_tcsncmp(line, cSciAutoCFromNCharKey, _countof(cSciAutoCFromNCharKey) - 1))
    {
        const unsigned pos = _countof(cSciAutoCFromNCharKey) - 1;
        _SciAutoCFromNChar = _tstoi(&line[pos]);
        if (_SciAutoCFromNChar < SCIAUTOCNCHAR_MIN || _SciAutoCFromNChar > SCIAUTOCNCHAR_MAX)
            _SciAutoCFromNChar = 3;
    }
    else
    {
        return false;
    }

    return true;
}


/**
 *  \brief
 */
bool DbConfig::Write(FILE* fp) const
{
    bool success = false;

    CText libDbPaths;
    DbPathsToBuf(libDbPaths, _T(';'));

    CText pathFilters;
    FiltersToBuf(pathFilters, _T(';'));

    if (_ftprintf_s(fp, _T("%s\n"), cInfo) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cParserKey, Parser()) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cAutoUpdateKey, (_autoUpdate ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cUseLibDbKey, (_useLibDb ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cLibDbPathsKey, libDbPaths.C_str()) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cUsePathFilterKey, (_usePathFilter ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cPathFiltersKey, pathFilters.C_str()) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cUseSciAutoCKey, (_useSciAutoC ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cSciAutoCIgnoreCaseKey, (_SciAutoCIgnoreCase ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%i\n"), cSciAutoCFromNCharKey, _SciAutoCFromNChar) > 0)
        success = true;

    return success;
}


/**
 *  \brief
 */
bool DbConfig::LoadFromFolder(const CPath& cfgFileFolder)
{
    SetDefaults();

    CPath cfgFile(cfgFileFolder);
    cfgFile += cPluginCfgFileName;

    if (!cfgFile.FileExists())
        return false;

    FILE* fp;
    _tfopen_s(&fp, cfgFile.C_str(), _T("rt"));
    if (fp == NULL)
        return false;

    bool success = true;

    TCHAR line[8192];
    while (_fgetts(line, _countof(line), fp))
    {
        // Comment or empty line
        if (line[0] == _T('#') || line[0] == _T('\n'))
            continue;

        // Strip newline from the end of the line
        line[_tcslen(line) - 1] = 0;

        if (!ReadOption(line))
        {
            success = false;
            SetDefaults();
            break;
        }
    }

    fclose(fp);

    return success;
}


/**
 *  \brief
 */
bool DbConfig::SaveToFolder(const CPath& cfgFileFolder) const
{
    CPath cfgFile(cfgFileFolder);
    cfgFile += cPluginCfgFileName;

    FILE* fp;
    _tfopen_s(&fp, cfgFile.C_str(), _T("wt"));
    if (fp == NULL)
        return false;

    bool success = Write(fp);
    fclose(fp);

    return success;
}


/**
 *  \brief
 */
void DbConfig::DbPathsFromBuf(TCHAR* buf, const TCHAR* separators)
{
    TCHAR* pTmp = NULL;
    for (TCHAR* ptr = _tcstok_s(buf, separators, &pTmp); ptr; ptr = _tcstok_s(NULL, separators, &pTmp))
    {
        CPath db(ptr);
        db.AsFolder();
        if (db.Exists())
            _libDbPaths.push_back(db);
    }
}


/**
 *  \brief
 */
void DbConfig::DbPathsToBuf(CText& buf, TCHAR separator) const
{
    vectorToBuf(_libDbPaths, buf, separator);
}


/**
 *  \brief
 */
void DbConfig::FiltersFromBuf(TCHAR* buf, const TCHAR* separators)
{
    TCHAR* pTmp = NULL;
    for (TCHAR* ptr = _tcstok_s(buf, separators, &pTmp); ptr; ptr = _tcstok_s(NULL, separators, &pTmp))
        _pathFilters.push_back(CPath(ptr));
}


/**
 *  \brief
 */
void DbConfig::FiltersToBuf(CText& buf, TCHAR separator) const
{
    vectorToBuf(_pathFilters, buf, separator);
}


/**
 *  \brief
 */
const DbConfig& DbConfig::operator=(const DbConfig& rhs)
{
    if (this != &rhs)
    {
        _parserIdx      = rhs._parserIdx;
        _autoUpdate     = rhs._autoUpdate;
        _useLibDb       = rhs._useLibDb;
        _libDbPaths     = rhs._libDbPaths;
        _usePathFilter  = rhs._usePathFilter;
        _pathFilters    = rhs._pathFilters;
        _useSciAutoC    = rhs._useSciAutoC;
        _SciAutoCIgnoreCase = rhs._SciAutoCIgnoreCase;
        _SciAutoCFromNChar  = rhs._SciAutoCFromNChar;
    }

    return *this;
}


/**
 *  \brief
 */
bool DbConfig::operator==(const DbConfig& rhs) const
{
    if (this == &rhs)
        return true;

    return (_parserIdx == rhs._parserIdx && _autoUpdate == rhs._autoUpdate &&
            _useLibDb == rhs._useLibDb && _libDbPaths == rhs._libDbPaths &&
            _usePathFilter == rhs._usePathFilter && _pathFilters == rhs._pathFilters &&
            _useSciAutoC == rhs._useSciAutoC && _SciAutoCIgnoreCase == rhs._SciAutoCIgnoreCase &&
            _SciAutoCFromNChar == rhs._SciAutoCFromNChar);
}


/**
 *  \brief
 */
void DbConfig::vectorToBuf(const std::vector<CPath>& vect, CText& buf, TCHAR separator)
{
    if (!vect.size())
        return;

    buf += vect[0];

    for (unsigned i = 1; i < vect.size(); ++i)
    {
        buf += separator;
        buf += vect[i];
    }
}


/**
 *  \brief
 */
Settings::Settings()
{
    SetDefaults();
}


/**
 *  \brief
 */
void Settings::SetDefaults()
{
    _useDefDb = false;
    _defDbPath.Clear();
    _re = false;
    _ic = false;

    _genericDbCfg.SetDefaults();
}


/**
 *  \brief
 */
bool Settings::Load()
{
    SetDefaults();

    CPath cfgFile;
    INpp::Get().GetPluginsConfDir(cfgFile);
    cfgFile += cPluginCfgFileName;

    if (!cfgFile.FileExists())
        return false;

    FILE* fp;
    _tfopen_s(&fp, cfgFile.C_str(), _T("rt"));
    if (fp == NULL)
        return false;

    bool success = true;

    TCHAR line[8192];
    while (_fgetts(line, _countof(line), fp))
    {
        // Comment or empty line
        if (line[0] == _T('#') || line[0] == _T('\n'))
            continue;

        // Strip newline from the end of the line
        line[_tcslen(line) - 1] = 0;

        if (!_tcsncmp(line, cUseDefDbKey, _countof(cUseDefDbKey) - 1))
        {
            const unsigned pos = _countof(cUseDefDbKey) - 1;
            if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
                _useDefDb = true;
            else
                _useDefDb = false;
        }
        else if (!_tcsncmp(line, cDefDbPathKey, _countof(cDefDbPathKey) - 1))
        {
            const unsigned pos = _countof(cDefDbPathKey) - 1;
            _defDbPath = &line[pos];
            _defDbPath.AsFolder();
            if (!_defDbPath.Exists())
                _defDbPath.Clear();
        }
        else if (!_tcsncmp(line, cREOptionKey, _countof(cREOptionKey) - 1))
        {
            const unsigned pos = _countof(cREOptionKey) - 1;
            if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
                _re = true;
            else
                _re = false;
        }
        else if (!_tcsncmp(line, cICOptionKey, _countof(cICOptionKey) - 1))
        {
            const unsigned pos = _countof(cICOptionKey) - 1;
            if (!_tcsncmp(&line[pos], _T("yes"), _countof(_T("yes")) - 1))
                _ic = true;
            else
                _ic = false;
        }
        else if (!_genericDbCfg.ReadOption(line))
        {
            success = false;
            SetDefaults();
            break;
        }
    }

    fclose(fp);

    return success;
}


/**
 *  \brief
 */
bool Settings::Save() const
{
    CPath cfgFile;
    INpp::Get().GetPluginsConfDir(cfgFile);
    cfgFile += cPluginCfgFileName;

    FILE* fp;
    _tfopen_s(&fp, cfgFile.C_str(), _T("wt"));
    if (fp == NULL)
        return false;

    bool success = false;
    if (_ftprintf_s(fp, _T("%s\n"), cInfo) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cUseDefDbKey, (_useDefDb ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cDefDbPathKey, _defDbPath.C_str()) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n"), cREOptionKey, (_re ? _T("yes") : _T("no"))) > 0)
    if (_ftprintf_s(fp, _T("%s%s\n\n"), cICOptionKey, (_ic ? _T("yes") : _T("no"))) > 0)
    if (_genericDbCfg.Write(fp))
        success = true;

    fclose(fp);

    if (success)
        _dirty = false;

    return success;
}


/**
 *  \brief
 */
const Settings& Settings::operator=(const Settings& rhs)
{
    if (this != &rhs)
    {
        _useDefDb       = rhs._useDefDb;
        _defDbPath      = rhs._defDbPath;
        _re             = rhs._re;
        _ic             = rhs._ic;
        _genericDbCfg   = rhs._genericDbCfg;
    }

    return *this;
}


/**
 *  \brief
 */
bool Settings::operator==(const Settings& rhs) const
{
    if (this == &rhs)
        return true;

    return (_useDefDb == rhs._useDefDb && _defDbPath == rhs._defDbPath &&
            _re == rhs._re && _ic == rhs._ic && _genericDbCfg == rhs._genericDbCfg);
}

} // namespace GTags
